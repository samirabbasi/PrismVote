# PrismVote

PrismVote is an encrypted voting dApp built on Zama FHEVM. It allows anyone to create time-bound polls,
cast encrypted votes, and publish publicly verifiable results after the poll ends.

## Overview

PrismVote focuses on privacy-preserving, verifiable polling:
- Votes are encrypted on-chain, so counts remain hidden while the poll is active.
- Anyone can finalize a poll after it ends to make the ciphertexts publicly decryptable.
- Decrypted results are verified on-chain before being recorded as the official outcome.

## Problems Solved

- Prevents early result leakage that can bias voter behavior.
- Removes reliance on a centralized tallying authority.
- Provides a public, tamper-evident audit trail for poll creation and final results.
- Keeps voter choice confidential while still allowing verifiable counting.

## Advantages

- Strong confidentiality: vote choices are encrypted from submission to reveal.
- Trust-minimized results: on-chain verification of decrypted counts.
- Permissionless operations: any user can vote and any user can end a poll after it closes.
- Clear lifecycle: create, vote, end, reveal, and publish results.
- Deterministic rules: fixed option count, time windows, and one vote per address.

## Key Features

- Create polls with 2-4 options and explicit start and end times.
- Encrypted voting using Zama FHEVM input proofs.
- On-chain encrypted tallying during the voting window.
- Public decryption enablement after the end time.
- On-chain result publication with decryption proof verification.

## How It Works

1. A creator submits a poll title, 2-4 options, and a start and end time.
2. Voters submit an encrypted choice plus an input proof.
3. The contract adds encrypted counts without revealing totals.
4. After the end time, anyone can call `endPoll` to make ciphertexts publicly decryptable.
5. A decryption service produces clear counts and a proof.
6. Anyone can call `publishResults` with the counts and proof to finalize results on-chain.

## Technology Stack

Smart contracts:
- Solidity 0.8.24
- Hardhat
- Zama FHEVM libraries

Frontend:
- React + Vite
- viem for read calls
- ethers for write calls
- RainbowKit for wallet connection
- No Tailwind

Tooling:
- TypeScript
- npm

## Repository Layout

```
PrismVote/
├── contracts/           # Smart contracts
├── deploy/              # Deployment scripts
├── deployments/         # Network deployment artifacts
├── tasks/               # Hardhat tasks
├── test/                # Contract tests
├── home/                # Frontend app (React + Vite)
└── hardhat.config.ts    # Hardhat configuration
```

## Setup and Usage

### Prerequisites

- Node.js 20+
- npm

### Install Dependencies

```bash
npm install
```

### Environment Configuration (Contracts Only)

Create a `.env` file in the repository root:

```
INFURA_API_KEY=your_key
PRIVATE_KEY=your_private_key
ETHERSCAN_API_KEY=optional_key
```

Notes:
- Deployments use a private key. Do not use a mnemonic.
- The frontend does not use environment variables.

### Compile and Test

```bash
npm run compile
npm run test
```

### Local Development Chain (Contracts)

```bash
npx hardhat node
npx hardhat deploy --network localhost
```

### Deploy to Sepolia

```bash
npx hardhat deploy --network sepolia
npx hardhat verify --network sepolia <CONTRACT_ADDRESS>
```

## Frontend Integration (home/)

The frontend is located in `home/` and must follow these rules:
- Use the ABI generated by the contract build from `deployments/sepolia` and copy it into source code.
- Do not import ABI JSON files directly in the frontend.
- Read calls use viem; write calls use ethers.
- Do not use localstorage.
- Do not use environment variables.
- Do not connect the frontend to a localhost network.
- Do not use Tailwind.
- Do not import files from the repository root.

Suggested workflow:
```bash
cd home
npm install
npm run dev
```

## Contract Interface Summary

- `createPoll(title, options, startTime, endTime)` creates a poll with 2-4 options.
- `vote(pollId, encryptedChoice, inputProof)` casts an encrypted vote.
- `endPoll(pollId)` makes encrypted counts publicly decryptable after the end time.
- `publishResults(pollId, clearCounts, decryptionProof)` verifies and stores the final results.
- `getPoll`, `getEncryptedCounts`, `getPublicCounts`, and `hasVoted` support data access.

## Security and Privacy Notes

- Voter identities (addresses) are public, but vote choices remain encrypted.
- The contract enforces one vote per address per poll.
- Counts remain confidential until `endPoll` is called and the decryption proof is verified.
- Block timestamps are used for start and end times.

## Limitations

- Polls are limited to 2-4 options.
- Only one vote per address is allowed.
- Decryption requires a valid proof from the Zama relayer workflow.
- Results are final once published on-chain.

## Future Plans

- Support for weighted voting while keeping ciphertexts private.
- Optional allowlists without revealing voter choice.
- Improved UX for handling input proofs and status states.
- Additional analytics based on public results.
- Multi-language UI and accessibility improvements.

## License

BSD-3-Clause-Clear. See `LICENSE`.
